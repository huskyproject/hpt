Улучшенные perl-хуки для hpt
                 редакция 1.05

0. Переход от стандартных на улучшенные perl-хуки
1. Общие константы и функции
2. Функции, вызываемые по событиям из hpt
3. Исправления и дополнения по сравнению со стандартными perl-хуками
4. Дополнительные perl-модули и программы

  --------------------------------------------------------------------
  0. Переход от стандартных на улучшенные perl-хуки

  Улучшенные perl-хуки на 99% совместимы с теми, что были раньше (далее они
  названы стандартными). Некоторые вещи (строковые флаги, даты) рекомендуется
  заменить на новую реализацию, т.к. в будущем их поддержка может быть
  прекращена. В случае, если после обновления версии hpt поменялась
  функциональность perl-хуков в Вашим скриптах, просьба сообщить об этом
  автору: val khokhlov, 2:550/180, val(at)vk(dot)kiev(dot)ua

  --------------------------------------------------------------------
  1. Общие константы и функции

  Флаги письма задаются в виде следующих констант:
PVT, CRA, RCV, SNT, ATT, TRS, ORP, K_S, LOC, HLD, RSV, FRQ, RRQ, RRC, ARQ, URQ,
A_S, DIR, ZON, HUB, IMM, XMA, KFS, TFS, LOK, CFM, HIR, COV, SIG, LET
  Их можно использовать либо как переменные ($PVT, $A_S), в т.ч. в строках;
  либо как вызовы функций (PVT, A_S), но только в обычном коде (не в строках
  или regex'ах) и при условии подключения модуля vtrack.

  Кроме того, для целей определения flavour, могут быть использованы
  численные значения флагов:
  CRA - crash, HLD - hold, DIR или CRA|HLD - direct, IMM - immediate
  Любое другое число (не строка!) воспринимается как normal

  В perl-коде можно использовать следующие read-only переменные:

  $hpt_ver     - версия hpt в таком виде: "hpt 1.2.0-stable/bsd"
  $hpt_version - версия hpt так, как она выводится самой программой
  %config      - хэш, в который записываются переменные из конфига:
    $config{inbound}
    $config{protInbound}
    $config{localInbound}
    $config{outbound}
    $config{name}
    $config{sysop}
    $config{origin}
    $config{dupeHistoryDir}
    $config{nodelistDir}
    $config{tempDir}
  %links       - хэш, в котором для каждого линка из конфига хранится
                 хэш его переменных, e.g. $links{'2:550/180'}{'name'}
                 (первым ключом служит aka линка, т.е. hisAka)
    $links{}{name}     - имя из Links
    $links{}{aka}      - наше aka, которое подставляется линку (ourAka)
    $links{}{password} - пароль из password
    $links{}{filebox}  - файлбокс для линка
    $links{}{flavour}  - flavour линка, берется из echoMailFlavour (за
                         неимением netMailFlavour), в виде флага (см.выше)

   Функции общего назначения:

  w_log([$level, ]$s) - записать строку в лог
      Параметры:
      $level - уровень (один символ), если не задан - используется LL_PERL
      $s     - строка


  str2attr($s) - преобразует строку с атрибутами в численное значение
      Параметры:
      $s - строка, в которой через пробел перечислены флаги ("sent" и т.п.)
  Использование этой функции не рекомендуется, лучше использовать числовые
  значения флагов.


  attr2str($attr) - выдает строковое представление флагов письма
      Параметры:
      $attr - флаги в бинарном виде
  Возращается строка трехсимвольных обозначений флагов, разделенных пробелами.
  Трехсимвольные обозначения: Pvt Cra K/s Rrq Att (аттач) Tfs A/S Sig и т.п.


  flv2str($flag) - выдает строковое представление flavour
      Параметры:
      $flag - представление flavour в виде бинарного флага письма
              (то, что хранится в $links{}{flavour}) или в виде строки
  Возвращаемые значения: IMM=>immediate, CRA=>crash, HLD=>hold, DIR=>direct,
  любое другое=>normal


  myaddr() - возвращает массив адресов данной системы
  Используйте @{$config{addr}} вместо вызова данной функции.


  nodelistDir() - возвращает каталог с нодлистом, т.е. nodelistDir из конфига
  Используйте $config{nodelistDir} вместо вызова данной функции.


  crc32($s) - возвращает crc-32 от аргумента по основанию -1
      Параметры:
      $s - строка, от которой нужно вычислить crc32
           длина строки определяет размер области памяти, от которого
           вычисляется crc


  alike($s1, $s2) - возвращает расстояние по Левенштейну между словами
                    (0-полное совпадение)
  Может быть использована для реализации нечеткой карбонки.
  Hапример: alike("HPT","JT")


  date_fts($dt) - перевод даты/времени из unixtime в формат fts-1
      Параметры:
      $dt - unixtime
  Возвращаемый формат: "dd mmm yy  hh:mm:ss", mmm - Jan, Feb, Mar...
  Не рекомендуется использовать дату/время в строковом виде в перл-хуках,
  для этого там есть соответствующий unixtime.


  fts_date($s) - перевод даты/времени из строки в формате fts-1 в unixtime
      Параметры:
      $s - строка, ожидается в формате "dd mmm yy  hh:mm:ss"
  Вообще, парсер из hpt может отпарсить дату и в некоторых других форматах
  либо вытащить хотя бы часть полей. Если вообще ничего не получится, то
  функция вернет undef.
  Не рекомендуется использовать дату/время в строковом виде в перл-хуках,
  для этого там есть соответствующий unixtime.


  mktime($sec, $min, $hour, $mday, $mon, $year[, $wday[, $yday[, $dst]]])
         - возвращает unixtime из своих аргументов
      Параметры:
      $sec  - секунды (00..59)
      $min  - минуты  (00..59)
      $hour - часы    (00..23)
      $mday - день месяцы (00..31)
      $mon  - месяц (00..11), 0 - январь
      $year - год (0..69 - для 2000..2069, >1900 - реальный год,
                   70..1900 - 1970..3800, т.е. 1900+значение)
      $wday - день недели (0..6), только для совместимости
      $yday - день года (0..365), только для совместимости
      $dst  - признак daylight saving time (0..1), только для совместимости
  Функция возвращает unixtime или 0 в случае ошибки.
  Для чего нужно 9 параметров? Если вызывать mktime(localtime), то
  используются все возвращаемые localtime 9 параметров, при этом корректно
  обрабатывается переход на летнее/зимнее время.
  Внимание! При использовании модуля POSIX могут возникнуть накладки, т.к.
  там такая функция тоже определена. Не импортируйте последнюю.


  strftime($format, [$unixtime])
  strftime($format, $sec, $min, $hour, $mday, $mon, $year[, $wday[, $yday[, $dst]]])
           - преобразует время в строку согласно формата
      Параметры:
      $format   - формат, см. man strftime
      $unixtime - использовать unixtime, если не задан - текущее время
      остальные - см. mktime
  Внимание! При использовании модуля POSIX могут возникнуть накладки, т.к.
  там такая функция тоже определена. Не импортируйте последнюю.


  gmtoff([$dt]) - возвращает разницу в часах между местным временем и
                  UTC (+3 означает, что у нас на 3 часа больше, чем GMT)
      Если задан параметр $dt, то расчет выполняется на заданное им время
  (обратите внимание - может учитываться переход на летнее/зимнее время).
  Если он не задан - разница по состоянию на сейчас.
      Технически вычисляется как разница между localtime() и gmtime().
  Может неправильно работать при разнице +-11..12 часов. Также, если есть
  разница в минутах, то возвращаемое значение будет не целым числом, т.е.
  +4.5 означает разницу в 4 часа 30 минут.


  putMsgInArea($area, $fromname, $toname, $fromaddr, $toaddr, $subject, 
               $date, $attr, $text[, $addkludges])
  * при использовании модуля vtrack имеет алиас post()
  - создает новое письмо в базе
      Параметры:
      $area              - тэг области, как записано в Area
                           если параметр не задан - первая нетмэйл-область
      $fromname, $toname - имена отправителя и получателя
      $fromaddr, $toaddr - соответствующие адреса
                           если $fromaddr = undef, берем aka для области
      $subject           - subj :)
      $date              - дата письма (unixtime)
                           если 0 или undef, берем текущую
                           также поддерживается для совместимости дата в виде
                           строки в формате fts-1
      $attr              - флаги письма (см. константы PVT, LOC, ...)
                           также поддерживаются для совместимости флаги в
                           виде строки
      $text              - текст
      $addkludges        - режим работы с кладжами (по умолчанию - 2):
          0 - текст письма не меняется (рекомендуется использовать его для
              копирования/перемещения существующих сообщений)
          1 - в текст письма вставляются кладжи INTL, TOPT, FMPT, FLAGS, MSGID,
              отражающие поля $fromaddr, $toaddr, $flags; если такие кладжи
              в письме уже есть, они вырезаются (рекомендуется использовать его
              при генерации нового письма на основании существующего: forward)
          2 - в текст письма вставляются только те кладжи INTL, TOPT, FMPT,
              MSGID, которых там не было; в FLAGS добавляются установленные в
              $attr флаги, но не удаляются обнуленные в $attr (используется,
              если нужно задать часть кладжей вручную)
          3 - в тесте письма обновляются кладжи INTL, TOPT, FMPT, FLAGS
              согласно параметров $toaddr, $fromaddr, $attr; причем сохраняется
              порядок кладжей (рекомендуется использовать его при изменении
              флагов или переадресации без создания нового сообщения)
  В тексте письма _все_ символы '\n' заменяются на '\r' (в соответствии 
  с fts1 символ '\n' будет игнорироваться).
  Если письмо создано успешно, то возвращается undef. Иначе - строка с
  сообщением об ошибке.

  --------------------------------------------------------------------
  2. Функции, вызываемые по событиям из hpt

  После компиляции скрипта осуществляется поиск всех имеющихся в нем
  функций из тех, что перечислены ниже. Если какой-то из них нет, то данное
  событие в перл не передается. Если во время выполнения какой-либо функции
  произошла ошибка (она запишется в лог), то данное событие больше в перл
  не передается.

  hpt_start() - не имеет параметров, вызывается при запуске hpt

  Внимание! Кроме того, перед вызовом этой функции выполняется тело скрипта.

  hpt_exit()  - не имеет параметров, вызывается при завершении hpt

  after_unpack() - вызывается после распаковки бандла в TempInbound

  before_pack() - вызывается перед началом паковки бандлов в TempOutbound
                  на линков


  process_pkt() - вызывается перед тоссингом .pkt
    Определены следующие переменные:
       $pktname - имя pkt-файла
       $secure - определена (defined), если pkt получен по парольному линку
                 (либо через LocalInbound)
    Возврат:
       если возвращается непустая строка, то pkt переименовывается в .flt и не
       обрабатывается дальше.


  pkt_done() - вызывается после завершение обработки .pkt
    Определены следующие переменные:
       $pktname - имя pkt-файла (в момент вызова он еще существует)
       $rc - код результата (0-все OK и $res не определена)
       $res - строковое представление $rc (на английском)
    Коды результатов и их значение на русском:
       0 - OK ($res не определена)
       1 - нарушение секретности (например, неверный пароль)
       2 - сложности с открытием .pkt-файла
       3 - неверный формат .pkt (возможно он битый)
       4 - .pkt не для нашей системы
       5 - проблемы с тоссингом сообщения


  filter() - вызывается при тоссинге новых писем
    Определены следующие переменные:
       переменная алиас (vtrack)
       $fromname  $sfrom - имя отправителя
       $fromaddr  $from  - адрес отправителя
       $toname    $sto   - имя получателя
       $toaddr    $to    - адрес получателя для нетмэйла или undef
       $area             - область для эхомэйла, иначе - undef
       $secure           - текущие сообщение получено через SecureInbound
       $subject   $subj  - subj
       $text             - текст сообщение(с кладжами)
       $date             - дата сообщения, переменная имеет два типа:
                           если используется как число - unixtime
                           если используется как строка - формат fts-1
       $attr             - атрибуты в виде числа
       $pktfrom          - от кого получен текущий pkt
    Возврат:
       $kill = 1         - удалить сообщение
       $change = 1       - изменить поля в соответствии с перечисленными
                           выше переменными (в т.ч. автоматом изменить кладжи)
                           (кроме $area, $secure, $pktfrom :)
       если возвращается непустая строка, то письмо помещается в badArea с
       этой причиной
  Не рекомендуется использовать атрибуты и дату/время в строковом виде.


  tossbad() - вызывается при тоссинге писем из badArea
    Определены следующие переменные:
       переменная алиас (vtrack)
       $fromname  $sfrom - имя отправителя
       $fromaddr  $from  - адрес отправителя
       $toname    $sto   - имя получателя
       $toaddr    $to    - адрес получателя для нетмэйла или undef
       $area             - область для эхомэйла, иначе - undef
       $subject   $subj  - subj
       $text             - текст сообщение(с кладжами)
       $date             - дата сообщения, переменная имеет два типа:
                           если используется как число - unixtime
                           если используется как строка - формат fts-1
       $attr             - атрибуты в виде числа
       $pktfrom          - от кого получен pkt
    Возврат:
       $change = 1       - изменить поля в соответствии с перечисленными
                           выше переменными (в т.ч. автоматом изменить кладжи)
                           (кроме $area, $secure, $pktfrom :)
       если возвращается непустая строка, то письмо удаляется с этой причиной
  Не рекомендуется использовать атрибуты и дату/время в строковом виде.


  scan() - вызывается при сканировании областей (hpt scan/hpt pack)
    Определены следующие переменные:
       переменная алиас (vtrack)
       $fromname  $sfrom - имя отправителя
       $fromaddr  $from  - адрес отправителя
       $toname    $sto   - имя получателя
       $toaddr    $to    - адрес получателя для нетмэйла или undef
       $area             - область, берется из Area
       $subject   $subj  - subj
       $text             - текст сообщение(с кладжами)
       $date             - дата сообщения, переменная имеет два типа:
                           если используется как число - unixtime
                           если используется как строка - формат fts-1
       $attr             - атрибуты в виде числа
    Возврат:
       $addvia = 0       - не добавлять строку Via: (см. также route())
       $kill   = 1       - удалить письмо после завершения функции
       $change = 1       - изменить поля в соответствии с перечисленными
                           выше переменными (в т.ч. автоматом изменить кладжи)
                           (кроме $area :)
       если возвращается непустая строка, то письмо не отсылается
  При изменении сообщения оно меняется только в памяти (т.е. hpt работает с
  измененным сообщением), но не в базе. Удаление письма работает как в случае
  его отсылки, так и в том случае, если оно не отсылается!
  Не рекомендуется использовать атрибуты и дату/время в строковом виде.


  route() - вызывается при определении роутинга нетмейлового сообщения
    Определены следующие переменные:
       переменная алиас (vtrack)
       $fromname  $sfrom - имя отправителя
       $from             - адрес отправителя
       $toname    $sto   - имя получателя
       $addr      $to    - адрес получателя
       $area             - область, берется из Area
       $subj             - subj
       $text             - текст сообщение(с кладжами)
       $date             - дата сообщения, переменная имеет два типа:
                           если используется как число - unixtime
                           если используется как строка - формат fts-1
       $attr             - атрибуты в виде числа
       $route            - роутинг из конфига, если он там есть ;)
    Возврат:
       $addvia = 0       - не добавлять строку Via:
       $change = 1       - изменить поля в соответствии с перечисленными
                           выше переменными (в т.ч. автоматом изменить кладжи)
                           (кроме $route :)
       $flavour          - спаковать письмо с данным flavour, который может
                           задаваться как атрибут (CRA, HLD, DIR, IMM) или
                           строка: c|cra|crash, h|hld|hold, d|dir|direct,
                           i|imm|immediate, n|norm|normal; по умолчанию hold
       если функция возвращает непустую строку, она считается адресом, на
  который пакуется данное письмо. Если же функция вернула пустую строку, но
  в конфиге не прописан роутинг, письмо никуда не отправляется.
       Переменная $addvia устанавливается в 1 до вызова scan(), ее можно
  поменять либо в scan(), либо в route(). Будучи установленной в 0, эта
  переменная отключает добавление строки Via: к упакованным письмам. К примеру,
  я добавляю строку Via: из route() с учетом моей aka для линка.

  --------------------------------------------------------------------
  3. Исправления и дополнения по сравнению со стандартными perl-хуками

  1) вместо createKludges используется новая функция, которая не допускает
     глюков с дублированием кладжей, а также добавляет режимы 2 и 3
     !!! внимательно прочтите, для чего нужен тот или иной режим
  2) полностью поддерживаются расширенные флаги в кладже FLAGS
  3) все переменные, определяющие заголовок письма, в filter(), tossbad(),
     scan() и route() можно менять
  4) дата и флаги сделаны в двоичном виде, так и удобнее и быстрее
  5) если в стандартных хуках не было какой-то функции, это вызывало ошибку
  6) добавлена hpt_start() и выполнение тела основного скрипта
  7) возможность управлять добавлением строки Via: через $addvia
  8) все символы '\n' заменяются на '\r', как оговорено в fts1; в стандартных
     хуках они заменялись только тогда, когда в тексте не было ни одного '\r'
     !!! это очень важный момент - единственная несовместимость, которую я внес
  9) удаление писем в scan() при $kill=1


  --------------------------------------------------------------------
  4. Дополнительные perl-модули и программы

  Модуль nidx (nidx.pm)
  ---------------------
  Данный модуль реализует поиск узла в нодлисте (через индексацию нодлиста).
  По адресу узла возвращается информация о его хабе, регионе и строка 
  из нодлиста.

  Этот модуль требует модуль DB_File. В свою очередь, для DB_File нужен
  пакет BerkleyDB (обычно есть в unix); либо для win32 можно взять бинарник
  этого модуля. Если в системе есть BerkleyDB без поддержки btree, то нужно
  в строке 20 ($db = tie...) поменять $DB_BTREE на $DB_HASH (посл.параметр).

  Использование: use nidx [qw(<funcs>)];
  <funcs> - список функций, которые можно импортнуть в контекст main::,
            разделенных пробелами; доступны: soft_check hub region nodeline

  Функции:

  nidx::init($nodelistDir[[, h], \%opts]) - инициализирует индекс
     $nodelistDir - каталог с нодлистом (см. $config{nodelistDir})
     h            - имя переменной в контексте main::, которую нужно связать
                    с индексом
     %opts        - опции, могут быть следующие:
                      soft_net:  1 или 0 (см. ncheck(), по умолчанию 0)
                      soft_zone: 1 или 0 (см. ncheck(), по умолчанию 0)
                      ok_zone:   ссылка массив (см. ncheck(), по умолчанию [])
                      w_log:     если 1, то писать в лог hpt (по умолчанию 0)
     пример: nidx::init($config{nodelistDir}, nidx)
     после этого получаем %nidx, где $nidx{'2:550/180'} определена, если
     узел 2:550/180 присутствует в нодлистах.

  nidx::done() - закрывает файлы индекса

  nidx::update(@masks) - при необходимости обновляет индекс
     @masks - массив regex, определяющих маски файлов нодлистов
     пример: nidx::update("nodelist\.\d{3}", "net_463\.\d{3}")
     Внимание: информация об узле всегда берется из последнего по списку
     листа, в котором он присутствует.
     При необходимости после маски могут стоять зона и регион для данного
     листа через двоеточие, например: "net_463\.\d{3}:2:46". Если же в листе
     нет строчки "Zone," и/или "Region," и они не указаны, то будет плохо :)

  nidx::compile(@files) - компилирует файлы из массива в индекс
     @files - массив с именами файлов (с путями)
     Внимание: функция вызывается из update(), вряд ли ее нужно использовать
     отдельно
     При необходимости после маски могут стоять зона и регион для данного
     листа через двоеточие, например: "net_463\.291:2:46".

  nidx::nodelists() - возвращает массив имен текущих нодлистов в индексе

  nidx::ncheck($addr) - "мягкая" проверка наличия узла в листах
     $addr - 3d/4d адрес (он всегда приводится к 3d, так что "2:550/180.8" и
             "2:550/180" равноценны)
     Возвращает 1, если узел $addr есть в нодлистах. Кроме того, возвращает 1,
     если узел в нодлистах не найден, но выполняется "мягкая" проверка по
     любому из условий:
      * soft_net==1: такой сети нет, но такая зона есть
      * soft_zone==1: такой сети нет и такой зоны нет
      * такой сети нет и такой зоны нет, но зона присутствует в массиве ok_zone
      * индекс нодлиста не найден, скомпилировать его не удалось, но зона
        присутствует в массиве ok_zone
     Если же ни одно из условий не выполнилось, то возвращается undef.
  Например, установка параметров nidx::init(,,{soft_net=>1, ok_zone=>[1..6]})
  приведет к тому, что присутствующими в нодлисте будут считаться:
      - все найденные там узлы
      - все узлы в отсутствующих сетях зон 1..6 (есть сеть вдруг потерялась или
        используется только сетевой сегмент, а не весь нодлист)
      - все узлы в отсутствующих зонах 1..6 (есть компилится лишь сегмент зоны)

  nidx::hub($addr) - возвращает хаба для узла $addr
     $addr - 3d/4d адрес (он всегда приводится к 3d, так что "2:550/180.8" и
             "2:550/180" равноценны)
     Возвращает адрес хаба, в подхабнике которого находится узел. Для узлов в
     подхостнике возвращается адрес хоста. Если узел не найден - undef.

  nidx::region($addr) - возвращает 2d-адрес региона для узла $addr
     $addr - 3d/4d адрес (он всегда приводится к 3d, так что "2:550/180.8" и
             "2:550/180" равноценны)
     Возвращает строку "zone:region" для узла. Если узел не найден - undef.

  nidx::nodeline($addr) - возвращает строку из нодлиста для узла $addr
     $addr - 3d/4d адрес (он всегда приводится к 3d, так что "2:550/180.8" и
             "2:550/180" равноценны)
     Возвращает строку из последнего по списку листа, в котором присутствует
     данный узел. Если узел не найден или ошибка чтения строки - undef.


  Модуль vtrack (vtrack.pm)
  -------------------------
  Модуль, реализующий функции, требуемые нетмэйл-трекеру.

  Использование: use vtrack;

  Модуль определяет константы PVT, LOC, ..., LET. Кроме того, модуль
  устанавливает следующие алиасы (псевдонимы для функций и переменных):
    post  - алиас для функции putMsgInArea()
    from  - алиас для $fromaddr
    to    - алиас для $toaddr и $addr
    sfrom - алиас для $fromname
    sto   - алиас для $toname
    subj  - алиас для $subject

  Функции:

  me($addr) - возвращает 1 если $addr - один из наших адресов, иначе - 0

  addvia([$link[, $utc]]) - добавляет строку Via: к письму
     $link - адрес линка, которому уходит письмо (в этом случае в строку
             Via подставляется наша aka для этого линка); если параметр не
             задан, то подставляется основной адрес
     $utc  - если 1, то время в строке Via указывается по UTC, иначе - местное

  age() - возвращает возраст письма в днях (по времени его написания)

  loop_cnt() - возвращает число прохождений письма через нашу систему, причем
               проверка идет по строке Via, по всем нашим адресам

  loop_age([$cnt]) - сколько дней назад письмо прошло через нашу систему 
     $cnt - если параметр задан, то возвращает кол-во дней с момента 
            $cnt-ого прохождения письма через нашу систему (нумерация с нуля), 
            undef в случае $cnt>=loop_cnt()
     если параметр не задан, возвращает массив, содержащий кол-во дней
     с моментов прохождения письма через нашу систему (в порядке строк Via)

  pack_age() - сколько часов назад письмо паковалось у нас последний раз
     функция смотрит последнюю строку Via, если она не нашей системы, то
     возвращается undef. Если же письмо последний раз паковалось на нашей
     системе, то возвращает разницу в часах с этого времени.

  att_check([$flags]) - проверяет наличие всех приаттаченных к письму файлов
     $flags - определяет, где искать файлы; по битам (по умолчанию - 3):
               бит 0 (0x01) : в секьюрном инбаунде (protInbound)
               бит 1 (0x02) : в обычном инбаунде (inbound)
               бит 2 (0x04) : в локальном инбаунде (localInbound)
     при этом, если в строке subj указаны пути к файлам, они игнорируются
     (берется только имя файла) и файлы все равно ищутся в инбаундах.
     Если данное письмо - не аттач, то возвращается 1.
     Если все файлы найдены, то возвращается 1. Иначе возвращается 0.

  att_cnt() - возвращает число приаттаченных к письму файлов
     возвращает undef, если письмо не аттач. Иначе разделяет строку subj по
     разделителям ' ' (пробел) и ',' и возвращает число непустых строк.

  att_size([$cnt[, $flags]]) - возвращает размер приаттаченного файла
     $cnt   - номер файла (нумерация начинается с нуля)
     $flags - где осуществлять поиск (см. att_check)
     если $cnt не задан, возвращается массив размеров всех приаттаченных
     файлов.
     Возвращает undef, если письмо не аттач, либо файл с таким номеров не
     найден, либо $cnt>=att_cnt(). Если $cnt не задан, то для ненайденных
     файлов соответствующий элемент возвращаемого массива будет undef.

  att_kill([$cnt[, $flags]]) - удаляет приаттаченный к письму файл
     $cnt   - номер файла (нумерация начинается с нуля)
     $flags - где осуществлять поиск (см. att_check)
     если $cnt не задан, удаляются все приаттаченные файлы.

  att_conv([$cnt]) - убирает пути к приаттаченным файлам
     $cnt   - номер файла (нумерация начинается с нуля)
     если $cnt не задан, удаляются все приаттаченные файлы.
  Функция работает с разделителями :, / и \.

